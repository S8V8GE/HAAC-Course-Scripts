####################################################################################################################
#                                               Introduction                                                       #
####################################################################################################################
"""
    Author:     James Savage
    Date:       6th August 2025

    Disclaimer:
    -----------
    This Python script is provided strictly for educational and illustrative purposes.
    It simulates Secure Messaging in MIFARE DESFire EV2, including the SelectApplication,
    AuthenticateEV2First, and ReadData commands.

    It is not intended for use in commercial, production, or security-critical environments,
    and should not be relied upon for any real-world security applications.

    This script is based on publicly available documentation and community knowledge, including:

        - NXP AN0945: MIFARE DESFire EV1/EV2 Features and Hints
          https://www.nxp.com/docs/en/application-note/AN0945.pdf

        - NXP AN10922: Key Diversification Guidelines
          https://www.nxp.com/docs/en/application-note/AN10922.pdf

        - ISO/IEC 7816-4: Integrated Circuit Cards â€“ APDU command formatting
          https://www.iso.org/standard/54550.html (note: official standard requires purchase)

        - Open-source community research and tools:
          - GitHub (e.g., libfreefare, pyDesfire, openkeychain)
          - RFID & smartcard forums (e.g., RFID Hacking Forum, Stack Overflow, NXP Community)

    This script does not expose any proprietary or NDA-protected information, nor does it
    replicate the exact behavior of real-world cards or readers.

    It is not affiliated with, endorsed by, or representative of any employer, company,
    or the MIFAREÂ® brand. Use at your own risk, and always consult certified specifications
    and libraries when building secure systems.
"""

####################################################################################################################
#                                Import from PyCryptoDome and others                                               #
####################################################################################################################
from Crypto.Cipher import AES
from Crypto.Hash import CMAC
from Crypto.Util.Padding import pad, unpad
import os
import binascii
import struct
import sys


####################################################################################################################
#                  Helper functions for encryption, decryption, and formatting                                     #
####################################################################################################################

def aes_encrypt(key, data):
    """Encrypt data using AES ECB mode."""
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.encrypt(data)


def aes_decrypt(key, data):
    """Decrypt data using AES ECB mode."""
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.decrypt(data)


def rotate_left(data):
    """Rotate bytes left by one position."""
    return data[1:] + data[:1]


def print_hex(label, data):
    """Print hex-formatted data."""
    print(f"{label}: {binascii.hexlify(data).decode().upper()}")


def cmac(key, data):
    """Generate CMAC for data using AES key."""
    cmac_obj = CMAC.new(key, ciphermod=AES)
    cmac_obj.update(data)
    return cmac_obj.digest()


def verify_cmac(expected_cmac, data, key):
    """Verify CMAC integrity by comparing with the expected CMAC."""
    computed_cmac = cmac(key, data)
    if computed_cmac == expected_cmac:
        print("CMAC Verification Successful: Integrity Check Passed")
    else:
        print("CMAC Verification Failed")


def left_shift(data):
    shifted = int.from_bytes(data, byteorder='big') << 1
    return (shifted & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF).to_bytes(16, byteorder='big')


def derive_subkeys(key):
    Rb = 0x87
    aes = AES.new(key, AES.MODE_ECB)

    # Step 1: Generate L
    L = aes.encrypt(b'\x00' * 16)

    # Step 2: Derive K1
    if L[0] & 0x80:  # Check MSB of L
        K1 = left_shift(L)
        K1 = bytearray(K1)
        K1[-1] ^= Rb
    else:
        K1 = left_shift(L)

    # Step 3: Derive K2
    if K1[0] & 0x80:  # Check MSB of K1
        K2 = left_shift(K1)
        K2 = bytearray(K2)
        K2[-1] ^= Rb
    else:
        K2 = left_shift(K1)

    return K1, K2


def reverse_bytes(data):
    reversed_data = data[::-1]
    print(f"Reversed {data.hex().upper()} to {reversed_data.hex().upper()}")
    return reversed_data


def print_a_break():
    return print(
        "#############################################################################################################################################")


####################################################################################################################
#                                  Define Variables Used for this Example                                          #
####################################################################################################################

# Note: ensure byte values are respected or the script won't work
master_key =    bytes.fromhex("D5A36CF065E7F4516748FB313187C6C8")           # Master Key (16 bytes)
uid =           bytes.fromhex("805FDF2A4D0404")                             # UID (7 bytes)
iv =            bytes.fromhex("00000000000000000000000000000000")           # IV (16 bytes)
private_id =    bytes.fromhex("000000000000000000000000BEEFCAFE")           # Private ID (16 bytes)
aid =           bytes.fromhex("BADB01")                                     # Application ID (3 bytes)
key_number =    bytes.fromhex("01")                                         # Key Number (1 byte)
padding =       bytes.fromhex("0000000000000000000000000000000000000000")   # Padding (20 bytes)
sub_key =       bytes.fromhex("01")                                         # Key Number (1 byte) - can be 01 (SubK_1) or 02 (SubK_2)
fid =           bytes.fromhex("01")                                         # File ID Number (1 byte)

####################################################################################################################
#                                  STEP 0 - Work out the Diversified Key                                           #
####################################################################################################################

print_a_break()
print("=== Step 0: Work out the Diversified Key ===")
print_a_break()

reversed_uid = reverse_bytes(uid)
reversed_aid = reverse_bytes(aid)

# Build the diversification data (32 bytes total)
diversification_data = bytes([0x01]) + reversed_uid + reversed_aid + key_number + padding
print(f"Diversification Data (before padding): {diversification_data.hex().upper()}")
print(f"Total Length of Diversification Data: {len(diversification_data)}")
assert len(diversification_data) == 32  # Ensure it's exactly 32 bytes

# Derive sub keys (SubK_1 and SubK_2)
SubK_1, SubK_2 = derive_subkeys(master_key)
if sub_key == bytes.fromhex("01"):
    print(f"SubK_1 (raw): {SubK_1.hex().upper()}")
elif sub_key == bytes.fromhex("02"):
    print(f"SubK_2 (raw): {SubK_2.hex().upper()}")
else:
    print(f"sub_key can only be 01 or 02, actual value: {sub_key.hex().upper()}")
    print("*** Exiting Script ***")
    exit()  # Exit the program here

# Prepend the 00 padding to the sub keys to make them 32 bytes long
SubK_1_padded = b'\x00' * (32 - len(SubK_1)) + SubK_1  # Prepend 00 padding to make it 32 bytes
SubK_2_padded = b'\x00' * (32 - len(SubK_2)) + SubK_2  # Prepend 00 padding to make it 32 bytes

# XOR the padded subkey (using the correct sub key) and diversification data
if sub_key == bytes.fromhex("01"):
    diversification_data_output = bytes(a ^ b for a, b in zip(diversification_data, SubK_1_padded))
    print(
        f"Diversification Data Output (after XOR with padded SubK_1 and Diversification Data): {diversification_data_output.hex().upper()}")
elif sub_key == bytes.fromhex("02"):
    diversification_data_output = bytes(a ^ b for a, b in zip(diversification_data, SubK_2_padded))
    print(
        f"Diversification Data Output (after XOR with padded SubK_2 and Diversification Data): {diversification_data_output.hex().upper()}")
else:
    print(f"sub_key can only be 01 or 02, actual value: {sub_key.hex().upper()}")
    print("*** Exiting Script ***")
    exit()  # Exit the program here

# Encrypt the diversification data output using AES CBC mode
cipher = AES.new(master_key, AES.MODE_CBC, iv)

# No need for padding if it's already 32 bytes
encrypted = cipher.encrypt(diversification_data_output)

# Show the encrypted result
print(f"Encrypted (CBC mode) output of:")
print(f"   - Master Key: {master_key.hex().upper()}")
print("     and")
print(f"   - Diversification Data: {diversification_data_output.hex().upper()}")
print(f"   - With an IV of: {iv.hex().upper()}")
print(f"Result: {encrypted.hex().upper()}")

# Extract the last 16 bytes as the diversified key
diversified_key = encrypted[-16:]
print(f"Diversified Key (last 16 bytes): {diversified_key.hex().upper()}")

####################################################################################################################
#                          STEP 1 - Reader Selects Application (Plain, No Encryption)                              #
####################################################################################################################

print()
print_a_break()
print("=== Step 1: Reader Sends SelectApplication Command ===")
print_a_break()

print("Purpose of this step:")
print("- The reader tells the card which application it wants to communicate with.")
print("- The card may contain multiple applications (like folders); this selects the correct one.")
print("- This command must be sent in **plaintext** because the reader and card are not yet in a secure session.")
print("- No keys are used for this step â€” this is purely to set the application context.")

# ----------------------------
# Build the APDU
# ----------------------------

# APDU Format (ISO/IEC 7816-4):
# CLA  | INS | P1  | P2  | Lc | AID      | Le
# 0x00 | 0xA4| 0x04| 0x00| 0x03| BADB01 | 0x02

cla = 0x00                          # Class byte â€“ ISO/IEC 7816 standard
ins = 0xA4                          # Instruction byte â€“ 'SELECT FILE'
p1 = 0x04                           # P1: Select by name (AID)
p2 = 0x00                           # P2: First or only occurrence
lc = len(aid)                       # Lc: Length of the AID (3 bytes)
le = 0x02                           # Le: Expect 2-byte response (SW1 SW2)

# Construct the full APDU command
select_apdu = bytes([cla, ins, p1, p2, lc]) + aid + bytes([le])

print(f"\nâ¡ï¸  Reader constructs APDU to select the application (AID = {aid.hex().upper()})")
print(f"Final APDU: {select_apdu.hex().upper()}")

# ----------------------------
# APDU Breakdown
# ----------------------------
print("\n-- Breakdown of SELECT APPLICATION APDU --")
print(f"{cla:02X}: CLA (Class byte) â€“ ISO/IEC 7816-4 standard command class")
print(f"{ins:02X}: INS (Instruction byte) â€“ 'SELECT FILE' command (0xA4)")
print(f"{p1:02X}: P1 â€“ Select by AID (Application Identifier)")
print(f"{p2:02X}: P2 â€“ Select first or only occurrence")
print(f"{lc:02X}: Lc â€“ Length of AID (3 bytes)")
print(f"{aid.hex().upper()}: AID â€“ Application Identifier (target app)")
print(f"{le:02X}: Le â€“ Expected length of response (2 bytes, SW1/SW2)")

# ----------------------------
# Simulate Card Response
# ----------------------------

print("\nğŸ“Ÿ Card receives the SelectApplication command...")

# Simulate a successful response (9000 = Success)
if aid == bytes.fromhex("BADB01"):
    sw1 = 0x90
    sw2 = 0x00
    print(f"\nâœ… The AID {aid.hex().upper()} **exists** on the card.")
    print("âœ… Card has now switched to that application context.")
else:
    sw1 = 0x6A
    sw2 = 0x82
    print(f"\nâŒ The AID {aid.hex().upper()} does **not exist** on the card.")
    print("âŒ The card cannot switch to a non-existent application.")

response_apdu = bytes([sw1, sw2])
print(f"\nâ¬…ï¸  Card responds with: {response_apdu.hex().upper()}")

# ----------------------------
# Response Breakdown
# ----------------------------
print("\n-- Breakdown of Card's Response (Status Words) --")
print(f"{sw1:02X}: SW1 â€“ Status byte 1")
print(f"{sw2:02X}: SW2 â€“ Status byte 2")

if response_apdu == bytes.fromhex("9000"):
    print("âœ”ï¸  9000 means: Command completed successfully â€“ the AID exists.")
    print("âœ”ï¸  The card has switched to the selected application's key set.")
else:
    print("âŒ  6A82 means: File/Application not found â€“ the AID does not exist on this card.")

# ----------------------------
# Security Notes
# ----------------------------
print("\n-- Security Note --")
print("ğŸ”“ No encryption or CMAC is used for SelectApplication.")
print("ğŸ”‘ No keys are used at this stage â€” the reader and card are not yet in a secure session.")
print("ğŸ” Once the application is selected, the reader must **authenticate** to prove it has the right to access protected data.")

####################################################################################################################
#                          STEP 2 - Reader Authenticates with 'AuthenticateEV2First'                               #
####################################################################################################################

print()
print_a_break()
print("=== Step 2: Reader Initiates Secure Session with AuthenticateEV2First ===")
print_a_break()

print("Purpose of this step:")
print("- Begin the process of mutual authentication using the Diversified Key.")
print("- The card will prove it knows the secret key by encrypting a random number (RndB).")
print("- The reader will then respond with its own random number (RndA) + rotated RndB, also encrypted.")
print("- Both parties will derive a shared **Session Key**, used to protect all future messages.")

####################################################################################################################
#                          STEP 2a - Reader Sends AuthenticateEV2First Command                                     #
####################################################################################################################

key_id = int.from_bytes(key_number, "big")

auth_apdu = bytes.fromhex(f"9071000001{key_id:02X}")

print(f"\nâ¡ï¸  Reader constructs AuthenticateEV2First APDU:")
print(f"APDU: {auth_apdu.hex().upper()}")

print("\n-- Breakdown of AuthenticateEV2First APDU --")
print("90: CLA â€“ Proprietary ISO/IEC 7816 command class")
print("71: INS â€“ AuthenticateEV2First instruction")
print("00: P1  â€“ Must be 0x00")
print("00: P2  â€“ Must be 0x00")
print("01: Lc  â€“ Length of following data (1 byte)")
print(f"{key_id:02X}: Key ID â€“ Specifies which key to authenticate against")

print("\nğŸ”“ This message is sent in plaintext â€“ encryption begins in the next step.")

####################################################################################################################
#                          STEP 2b - Card Responds with Encrypted RndB + CMAC                                      #
####################################################################################################################

print()
print_a_break()
print("=== Step 2b: Card Responds with Encrypted RndB + CMAC ===")
print_a_break()

rndB = os.urandom(16)
print(f"ğŸ§¬ Card generates random number RndB: {rndB.hex().upper()}")

enc_rndB = aes_encrypt(diversified_key, rndB)
print(f"ğŸ” Card encrypts RndB with Diversified Key ({diversified_key.hex().upper()}):")
print(f"Encrypted RndB: {enc_rndB.hex().upper()}")

cmac_obj = CMAC.new(diversified_key, ciphermod=AES)
cmac_obj.update(enc_rndB)
cmac_card = cmac_obj.digest()[:8] # Truncated to 8 bytes per AN0945 Secure Messaging spec
print(f"ğŸ§¾ Card generates CMAC (8 bytes, AES-CMAC truncated): {cmac_card.hex().upper()}")

card_response = enc_rndB + cmac_card
print(f"\nâ¬…ï¸  Card sends: Encrypted RndB + CMAC")
print(f"Response: {card_response.hex().upper()}")

####################################################################################################################
#                          STEP 2c - Reader Responds with Encrypted RndA + Rotated RndB + CMAC                     #
####################################################################################################################

print()
print_a_break()
print("=== Step 2c: Reader Responds with Encrypted RndA + Rotated RndB + CMAC ===")
print_a_break()

rndB_decrypted = aes_decrypt(diversified_key, enc_rndB)
print(f"ğŸ”“ Reader decrypts RndB using Diversified Key:")
print(f"Decrypted RndB: {rndB_decrypted.hex().upper()}")

rndA = os.urandom(16)
print(f"ğŸ§¬ Reader generates random number RndA: {rndA.hex().upper()}")

rotated_rndB = rotate_left(rndB_decrypted)
print(f"ğŸ”„ Reader rotates RndB left by 1 byte: {rotated_rndB.hex().upper()}")

message = rndA + rotated_rndB
print(f"\nğŸ§± Message to Encrypt: RndA || rotated RndB")
print(f"Plaintext: {message.hex().upper()}")

enc_message = aes_encrypt(diversified_key, message)
print(f"ğŸ” Reader encrypts message with Diversified Key:")
print(f"Encrypted message: {enc_message.hex().upper()}")

cmac_obj = CMAC.new(diversified_key, ciphermod=AES)
cmac_obj.update(enc_message)
cmac_reader = cmac_obj.digest()[:8]
print(f"ğŸ§¾ Reader generates CMAC: {cmac_reader.hex().upper()}")

reader_response = enc_message + cmac_reader
print(f"\nâ¡ï¸  Reader sends: Encrypted (RndA || rotated RndB) + CMAC")
print(f"Data sent to card: {reader_response.hex().upper()}")

####################################################################################################################
#                          STEP 2d - Card Verifies Reader's Response                                               #
####################################################################################################################

print()
print_a_break()
print("=== Step 2d: Card Verifies Reader's Response ===")
print_a_break()

card_enc_msg = reader_response[:-8]
card_received_cmac = reader_response[-8:]

cmac_obj = CMAC.new(diversified_key, ciphermod=AES)
cmac_obj.update(card_enc_msg)
expected_cmac = cmac_obj.digest()[:8]

print(f"ğŸ§¾ Card recalculates CMAC: {expected_cmac.hex().upper()}")
print(f"CMAC received from reader: {card_received_cmac.hex().upper()}")

if expected_cmac == card_received_cmac:
    print("âœ… CMAC is valid â€“ message was not altered")
else:
    print("âŒ CMAC is invalid â€“ possible tampering")

decrypted = aes_decrypt(diversified_key, card_enc_msg)
card_rndA = decrypted[:16]
card_rotated_rndB = decrypted[16:]
expected_rotated_rndB = rotate_left(rndB)

print(f"\nğŸ”“ Card decrypts payload:")
print(f"RndA from reader: {card_rndA.hex().upper()}")
print(f"Rotated RndB from reader: {card_rotated_rndB.hex().upper()}")
print(f"Expected rotated RndB: {expected_rotated_rndB.hex().upper()}")

if card_rotated_rndB == expected_rotated_rndB:
    print("âœ… Rotated RndB is valid â€“ reader proved knowledge of secret key")
    print("ğŸ¤ Mutual authentication successful â€“ session key can now be derived")
else:
    print("âŒ Rotated RndB mismatch â€“ reader authentication failed")

####################################################################################################################
#                          STEP 2e - Derive Shared Session Key                                                     #
####################################################################################################################

print()
print_a_break()
print("=== Step 2e: Both Reader and Card Derive the Shared Session Key ===")
print_a_break()

print("Purpose of this step:")
print("- Both the card and the reader independently derive the same Session Key (SK).")
print("- This key will be used to protect all further communication using encryption (ENC) and authentication (CMAC).")
print("- The key is derived from known values RndA and RndB using AES-CMAC, as defined in NXP's AN0945 spec.")

# ----------------------------------------------------------------
# ğŸ”¢ Step 1: Extract required parts from RndA and RndB
# ----------------------------------------------------------------
print("\nStep 1: Extract input for Key Derivation (KeyData)")

print("According to NXP AN0945, the session key is derived from:")
print("RndA[0:4] || RndB[0:4] || RndA[12:16] || RndB[12:16]")

key_data = rndA[0:4] + rndB[0:4] + rndA[12:16] + rndB[12:16]

print(f"\nKeyData Components:")
print(f"RndA[0:4]:       {rndA[0:4].hex().upper()}")
print(f"RndB[0:4]:       {rndB[0:4].hex().upper()}")
print(f"RndA[12:16]:     {rndA[12:16].hex().upper()}")
print(f"RndB[12:16]:     {rndB[12:16].hex().upper()}")
print(f"\nğŸ§± Combined KeyData (16 bytes): {key_data.hex().upper()}")

# ----------------------------------------------------------------
# ğŸ” Step 2: Calculate AES-CMAC over KeyData using Diversified Key
# ----------------------------------------------------------------
print("\nStep 2: Derive Session Key from KeyData using AES-CMAC")

print("Explanation:")
print("- The 16-byte KeyData is used as the message input to AES-CMAC.")
print("- The diversified key is used as the CMAC key.")
print("- The full 16-byte CMAC output is used directly as the Session Key (SK).")

cmac_obj = CMAC.new(diversified_key, ciphermod=AES)
cmac_obj.update(key_data)
session_key = cmac_obj.digest()

print(f"\nğŸ” Diversified Key used for CMAC: {diversified_key.hex().upper()}")
print(f"ğŸ§® CMAC result (Session Key):     {session_key.hex().upper()}")

print("\nğŸ§  Final Result:")
print("âœ… Session Key successfully derived.")
print("ğŸ” This key will now be used to encrypt and authenticate all subsequent messages.")

####################################################################################################################
#                          STEP 3a - Reader Sends Secure Wrapped 'ReadData' Command                                #
####################################################################################################################

print()
print_a_break()
print("=== Step 3a: Reader Sends Secure Wrapped 'ReadData' Command ===")
print_a_break()

print("ğŸ§  Purpose of this step:")
print("- Read 16 bytes from a specific file (defined in `fid`) on the DESFire EV2 card.")
print("- Use Secure Messaging (SM) to encrypt the command and add a CMAC to protect its integrity.")
print("- All encryption and MACs are done using the **Session Key**, not the diversified key.")

# ----------------------------------------------------------------------------------
# Step 0: Setup parameters from variables
# ----------------------------------------------------------------------------------

# Use variables already defined:
file_id = int.from_bytes(fid, "big")       # File ID from variable 'fid'
offset = 0x000000                                   # Read from start of file
length = 0x10                                       # Read 16 bytes

# TI and CmdCtr from **simulated** secure session state
TI = bytes.fromhex("A1B2C3D4")            # Normally from card after mutual auth
CmdCtr = 1                                # Command counter starts at 1 per session
# note that these are dynamically returned by real cards and incremented per command.

print(f"ğŸ“ File ID (from `fid`): {fid.hex().upper()} (interpreted as int: {file_id:02X})")
print(f"ğŸ“ Offset in file:        {offset:06X}")
print(f"ğŸ“¦ Number of bytes:       {length}")
print(f"ğŸ§® Command Counter:        {CmdCtr:04X} (increases with each command in session)")
print(f"ğŸ”— Transaction Identifier: {TI.hex().upper()} (used in ENC + CMAC derivation)")

# ----------------------------------------------------------------------------------
# Step 1: Construct the plaintext parameters of the ReadData command
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ“¦ Step 1: Build Plaintext Command Parameters")

# Format per NXP: [FileID (1B)] + [Offset (3B)] + [Length (3B)]
cmd_data = (
    struct.pack(">B", file_id) +
    struct.pack(">I", offset)[1:] +
    struct.pack(">I", length)[1:]
)

print(f"ğŸ§± Plain Command Data: {cmd_data.hex().upper()} (FileID | Offset[3] | Length[3])")

# ----------------------------------------------------------------------------------
# Step 2: Encrypt the parameters (ENC) using the Session Key
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ” Step 2: Encrypt Command Parameters using Session Key (ENC)")

# Per NXP: IV = CMAC(SessionKey, TI || CmdCtr || 0x00)
iv_input = TI + CmdCtr.to_bytes(2, "big") + b"\x00"
cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(iv_input)
enc_iv = cmac_obj.digest()

print(f"ğŸ§ª ENC IV input: TI || CmdCtr || 0x00 = {iv_input.hex().upper()}")
print(f"ğŸ”‘ Derived IV for ENC: {enc_iv.hex().upper()}")

# Pad and encrypt
padded_cmd = pad(cmd_data, AES.block_size)
cipher = AES.new(session_key, AES.MODE_CBC, enc_iv)
enc_cmd = cipher.encrypt(padded_cmd)

print(f"ğŸ“¥ Padded Command Data (PKCS#7): {padded_cmd.hex().upper()}")
print(f"ğŸ” Encrypted Command Payload (ENC): {enc_cmd.hex().upper()}")
print(f"ğŸ”‘ Key used: Session Key ({session_key.hex().upper()})")

# ----------------------------------------------------------------------------------
# Step 3: Generate CMAC over the command (for integrity)
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ§¾ Step 3: Generate CMAC to ensure message integrity")

# APDU header for ReadData: CLA | INS | P1 | P2
apdu_header = bytes.fromhex("90BD0000")
Lc = len(enc_cmd)  # Length of encrypted data

# Build CMAC input per NXP spec
cmac_input = (
    TI +
    CmdCtr.to_bytes(2, "big") +
    apdu_header[1:] +           # INS, P1, P2
    bytes([Lc]) +               # Length of ENC
    enc_cmd                     # Encrypted data
)

print(f"ğŸ§¾ CMAC input: TI || CmdCtr || INS || P1 || P2 || Lc || ENC")
print(f"Data to MAC: {cmac_input.hex().upper()}")

cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(cmac_input)
full_cmac = cmac_obj.digest()
trunc_cmac = full_cmac[:8]

print(f"ğŸ” Full CMAC: {full_cmac.hex().upper()}")
print(f"âœ‚ï¸  Truncated CMAC (8 bytes): {trunc_cmac.hex().upper()}")
print(f"ğŸ”‘ Key used: Session Key ({session_key.hex().upper()})")

# ----------------------------------------------------------------------------------
# Step 4: Build final wrapped APDU to send to the card
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ“¦ Step 4: Construct Final Secure APDU to Send")

final_apdu = (
    apdu_header +                        # CLA | INS | P1 | P2
    bytes([Lc + len(trunc_cmac)]) +      # Lc = ENC + CMAC
    enc_cmd +                            # Encrypted data
    trunc_cmac +                         # CMAC
    b"\x00"                              # Le
)

print(f"\nâ¡ï¸  Final Secure Wrapped ReadData APDU: {final_apdu.hex().upper()}")

print("\nğŸ“– Final APDU Breakdown:")
print(f"CLA: {apdu_header[0]:02X} â€“ Proprietary instruction class")
print(f"INS: {apdu_header[1]:02X} â€“ Instruction code (ReadData)")
print("P1:  00 â€“ Default parameter")
print("P2:  00 â€“ Default parameter")
print(f"Lc:  {Lc + len(trunc_cmac)} â€“ Length of ENC + CMAC")
print("ENC: Encrypted command payload")
print("CMAC: 8-byte truncated CMAC")
print("Le:  00 â€“ Expect response from card")

print_a_break()
print("âœ… Step 3a Complete: Command is protected with Secure Messaging")
print(f"ğŸ” Encryption Key Used: Session Key ({session_key.hex().upper()})")
print("ğŸ” IV derived from TI and CmdCtr to ensure uniqueness")
print("ğŸ§¾ CMAC ensures message integrity and authenticity")
print("ğŸ“¤ Command is now ready to be sent to the card securely")

####################################################################################################################
#                          STEP 3b â€“ Card Receives, Validates, and Decrypts ReadData Command                       #
####################################################################################################################

print()
print_a_break()
print("=== Step 3b: Card Receives Secure Wrapped 'ReadData' Command ===")
print_a_break()

print("ğŸ§  Purpose of this step:")
print("- Simulate how the card handles a Secure Messaging ReadData command.")
print("- It must:")
print("   1ï¸âƒ£ Verify the CMAC is correct (ensures integrity)")
print("   2ï¸âƒ£ Decrypt the ENC payload (to extract FileID, Offset, Length)")
print("   3ï¸âƒ£ Perform the file access using real data (from `private_id`)")
print("   4ï¸âƒ£ Send an encrypted + CMAC-protected response using the Session Key")

# ----------------------------------------------------------------------------------
# Step 1: Parse the APDU sent by the reader
# ----------------------------------------------------------------------------------

print("\nğŸ“¦ Step 1: Parse Incoming APDU")

# We'll assume `final_apdu` is still in memory from Step 3a...
cla = final_apdu[0]
ins = final_apdu[1]
p1 = final_apdu[2]
p2 = final_apdu[3]
lc = final_apdu[4]
enc_len = lc - 8

enc_data = final_apdu[5:5+enc_len]
recv_cmac = final_apdu[5+enc_len:5+enc_len+8]
le = final_apdu[-1:]

print(f"ğŸ“¨ APDU Received:")
print(f"  CLA: {cla:02X}")
print(f"  INS: {ins:02X}")
print(f"  P1:  {p1:02X}")
print(f"  P2:  {p2:02X}")
print(f"  Lc:  {lc} bytes (ENC + CMAC)")
print(f"  ENC Payload: {enc_data.hex().upper()}")
print(f"  CMAC Received: {recv_cmac.hex().upper()}")
print(f"  Le: {le.hex().upper()}")

# ----------------------------------------------------------------------------------
# Step 2: Validate the CMAC
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ§¾ Step 2: Card Validates CMAC of the Incoming Command")

cmac_input_card = (
    TI +
    CmdCtr.to_bytes(2, "big") +
    bytes([ins, p1, p2]) +
    bytes([enc_len]) +
    enc_data
)

cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(cmac_input_card)
expected_cmac = cmac_obj.digest()[:8]

print(f"ğŸ” Reconstructed CMAC input: {cmac_input_card.hex().upper()}")
print(f"ğŸ§¾ CMAC calculated by card: {expected_cmac.hex().upper()}")
print(f"ğŸ“¬ CMAC received from reader: {recv_cmac.hex().upper()}")

if expected_cmac != recv_cmac:
    print("âŒ CMAC verification failed! Reader command may have been tampered with.")
    sys.exit(1)
else:
    print("âœ… CMAC verification succeeded â€“ integrity confirmed")

# ----------------------------------------------------------------------------------
# Step 3: Decrypt the ENC payload to get command parameters
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ”“ Step 3: Decrypt ENC Payload using Session Key")

# Re-derive IV: TI || CmdCtr || 0x00
iv_input = TI + CmdCtr.to_bytes(2, "big") + b"\x00"
cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(iv_input)
dec_iv = cmac_obj.digest()

print(f"ğŸ”‘ Derived IV for decryption: {dec_iv.hex().upper()}")

cipher = AES.new(session_key, AES.MODE_CBC, dec_iv)
decrypted_data = unpad(cipher.decrypt(enc_data), AES.block_size)

file_id_dec = decrypted_data[0]
offset_dec = int.from_bytes(decrypted_data[1:4], "big")
length_dec = int.from_bytes(decrypted_data[4:7], "big")

print(f"ğŸ”“ Decrypted Command Data: {decrypted_data.hex().upper()}")
print(f"ğŸ“„ File ID:  {file_id_dec:02X}")
print(f"ğŸ“ Offset:   {offset_dec}")
print(f"ğŸ“ Length:   {length_dec} bytes")

# ----------------------------------------------------------------------------------
# Step 4: Prepare Encrypted Response using `private_id`
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ“¤ Step 4: Card Prepares Secure Response to Reader")

# Use the variable defined `private_id`
file_contents = private_id[:length_dec]
print(f"ğŸ“ Simulated File Content (from variable `private_id`): {file_contents.hex().upper()} ({len(file_contents)} bytes)")

# Step 4a â€“ Encrypt response data using Session Key + derived IV
iv_input_resp = TI + CmdCtr.to_bytes(2, "big") + b"\x01"
cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(iv_input_resp)
resp_iv = cmac_obj.digest()

cipher = AES.new(session_key, AES.MODE_CBC, resp_iv)
padded_response = pad(file_contents, AES.block_size)
enc_response = cipher.encrypt(padded_response)

print(f"ğŸ§ª IV input for ENC: {iv_input_resp.hex().upper()}")
print(f"ğŸ”‘ Derived Response ENC IV: {resp_iv.hex().upper()}")
print(f"ğŸ“¥ Padded Response Data: {padded_response.hex().upper()}")
print(f"ğŸ” Encrypted Response: {enc_response.hex().upper()}")
print(f"ğŸ”‘ Encryption Key Used: Session Key ({session_key.hex().upper()})")

# Step 4b â€“ Generate Response CMAC
status_code = bytes.fromhex("9100")
cmac_input_resp = TI + CmdCtr.to_bytes(2, "big") + enc_response + status_code

cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(cmac_input_resp)
resp_cmac = cmac_obj.digest()[:8]

print(f"\nğŸ§¾ Response CMAC input: TI || CmdCtr || ENC || StatusCode")
print(f"Data to MAC: {cmac_input_resp.hex().upper()}")
print(f"ğŸ” Truncated Response CMAC (8 bytes): {resp_cmac.hex().upper()}")

# Final response from card = ENC || CMAC || Status Code
full_response = enc_response + resp_cmac + status_code

print_a_break()
print("âœ… Step 3b Complete: Card Response Ready to Send")
print(f"ğŸ“¤ Final Response to Reader: {full_response.hex().upper()}")
print("ğŸ’¡ Reader will now decrypt this using the Session Key and validate the CMAC.")

####################################################################################################################
#                       STEP 3c â€“ Reader Receives Response, Verifies CMAC, and Decrypts Data                      #
####################################################################################################################

print()
print_a_break()
print("=== Step 3c: Reader Receives Encrypted Response from Card ===")
print_a_break()

print("ğŸ§  Purpose of this step:")
print("- The reader receives the cardâ€™s encrypted response.")
print("- It must:")
print("   1ï¸âƒ£ Verify the CMAC to ensure response wasnâ€™t tampered with.")
print("   2ï¸âƒ£ Decrypt the ENC payload using the Session Key and correct IV.")
print("   3ï¸âƒ£ Remove any padding and extract the actual file content.")
print("   4ï¸âƒ£ Confirm the result matches what we expect (e.g. private_id).")

# ----------------------------------------------------------------------------------
# Step 1: Parse the response from the card
# ----------------------------------------------------------------------------------

response_data = full_response  # This should be the final card response from Step 3b?
enc_response = response_data[:-10]  # Exclude CMAC and Status
cmac_received = response_data[-10:-2]
status_word = response_data[-2:]

print("ğŸ“¨ Response from card:")
print(f"ğŸ” Encrypted Response Data: {enc_response.hex().upper()}")
print(f"ğŸ§¾ Response CMAC: {cmac_received.hex().upper()}")
print(f"ğŸ“Ÿ Status Word: {status_word.hex().upper()}")

# ----------------------------------------------------------------------------------
# Step 2: Validate the CMAC
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ§¾ Step 2: Reader Verifies CMAC of Response")

cmac_input = TI + CmdCtr.to_bytes(2, "big") + enc_response + status_word
cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(cmac_input)
expected_cmac = cmac_obj.digest()[:8]

print(f"ğŸ§ª CMAC Input: TI || CmdCtr || ENC || Status")
print(f"Data to MAC: {cmac_input.hex().upper()}")
print(f"ğŸ” Calculated CMAC: {expected_cmac.hex().upper()}")
print(f"ğŸ“¬ Received CMAC:   {cmac_received.hex().upper()}")

if expected_cmac != cmac_received:
    print("âŒ CMAC mismatch â€“ response may have been tampered with.")
    sys.exit(1)
else:
    print("âœ… CMAC verified â€“ response integrity confirmed.")

# ----------------------------------------------------------------------------------
# Step 3: Decrypt the response data
# ----------------------------------------------------------------------------------

print_a_break()
print("ğŸ”“ Step 3: Decrypt Response Data")

# IV for response decryption: TI || CmdCtr || 0x01
iv_input = TI + CmdCtr.to_bytes(2, "big") + b"\x01"
cmac_obj = CMAC.new(session_key, ciphermod=AES)
cmac_obj.update(iv_input)
dec_iv = cmac_obj.digest()

print(f"ğŸ§¬ Response Decryption IV Input: {iv_input.hex().upper()}")
print(f"ğŸ”‘ Derived Decryption IV: {dec_iv.hex().upper()}")
print(f"ğŸ” Session Key Used: {session_key.hex().upper()}")

cipher = AES.new(session_key, AES.MODE_CBC, dec_iv)
plaintext = unpad(cipher.decrypt(enc_response), AES.block_size)

print(f"ğŸ“¦ Decrypted and Unpadded Response: {plaintext.hex().upper()}")

# ----------------------------------------------------------------------------------
# Step 4: Compare to Expected Data (from private_id)
# ----------------------------------------------------------------------------------

expected_data = private_id[:length_dec]

print(f"\nğŸ“ Expected File Content (from variable `private_id`): {expected_data.hex().upper()}")
if plaintext == expected_data:
    print("âœ… Response matches expected file content â€“ secure messaging worked correctly!")
else:
    print("âŒ Data mismatch â€“ something went wrong during encryption or CMAC verification.")
